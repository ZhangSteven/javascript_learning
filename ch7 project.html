<script>
/*
	Project: A Robot
*/

let x = Object.create(null);	// an object with no properties
								// no prototype
console.log(x);

let y = {}						// an object with prototype Object.prototype
								// has methods like hasOwnProperty() etc.
console.log(y);

// roads in the town.
const roads = [
	"Alice's House-Bob's House",   "Alice's House-Cabin",
	"Alice's House-Post Office",   "Bob's House-Town Hall",
	"Daria's House-Ernie's House", "Daria's House-Town Hall",
	"Ernie's House-Grete's House", "Grete's House-Farm",
	"Grete's House-Shop",          "Marketplace-Farm",
	"Marketplace-Post Office",     "Marketplace-Shop",
	"Marketplace-Town Hall",       "Shop-Town Hall"
];

// But the array of strings isn't very interesting to work with. What we
// are interested in is the destination that we can reach from a given
// place. So here, we convert the roads into a data structure that, for
// each place, tells us what can be reached from there.
function buildGraph(edges){
	let graph = Object.create(null);
	function addEdge(from, to){
		if (graph[from] == undefined){
			graph[from] = [to];
		} else {
			graph[from].push(to);
		}
	}

	for (let [from, to] of roads.map(r => r.split('-'))){
		addEdge(from, to);
		addEdge(to, from);
	}

	return graph;
}

const roadGraph = buildGraph(roads);
console.log(roadGraph);

/*
	If we define a class for each type of things in the problem, like
	the robot, the houses, the roads, the parcels, then we may end up
	a program with lots of interconnected objects each having their
	own state, which is hard to understand and easy to break.

	Instead, let's condense the village's state down to the minimul set
	of values that define it. There's the robot's current location and
	the collection of undelivered parcels, each of which has a current
	location and a destination address.
*/
class VillageState {
	constructor(place, parcels) {
		this.place = place;
		this.parcels = parcels;
	}

	/*
		Update the state of all parcels {place, address}, as below:

		1. For those not at the current location (p.place != this.place), 
			they are not picked up yet, so no change.
		2. For those at the current location, they are picked up and
			moved to next stop (p.place = destination).
		3. Remove those delivered (p.place = p.address).

		Finally return a new VillageState object reflecting the new
		state, the robot's location and the parcels' state.
	*/
	move(destination){
		if (!roadGraph[this.place].includes(destination)) return this;
		let parcels = this.parcels.map(p => {
			if (p.place != this.place) {
				return p;
			} else {
				return {place: destination, address: p.address};
			}
		}).filter(p => p.place != p.address);

		return new VillageState(destination, parcels);
	}
}

// test it.
let first = new VillageState('Post Office', 
							[{place: 'Post Office', address: "Alice's House"}]);
let next = first.move("Alice's House");
console.log(next.place);
console.log(next.parcels);
console.log(first.place);



/*
	Make a delivery robot.

	Since we already have the VillageState object to describe the state
	of the world, what we need is a robot that can tell what is the next
	move. The robot can be seen as a function whose input is the current
	state (state), maybe past moves (memory), and return the decision 
	(direction) and updated memory.
*/
function runRobot(state, robot, memory){
	for (let turn=0;;turn++){
		if (state.parcels.length == 0){
			console.log(`Done in ${turn} turns`);
			break;
		}

		let direction;
		[direction, memory] = robot(state, memory);
		state = state.move(direction);
		console.log(`Moved to ${direction}`);
	}
}



/*
	A random robot.

	The simpliest robot just moves randomly in every turn. Given enough
	time, we can expect it to run into every location that has parcels
	to deliver and send those parcels to their destination.
*/
function randomPick(array){
	let choice = Math.floor(Math.random() * array.length);
	return array[choice];
}

function randomRobot(state){
	return [randomPick(roadGraph[state.place]), null];
}



/*
	Test robots.

	To setup the test, we can add a static method to the VillageState
	class, random, to initialize the setup of parcels waiting to be
	delivered. The starting position the robot is assumed to be at
	'Post Office'.
*/
VillageState.random = function(parcelCount = 5){
	let parcels = [];
	for (let i=0; i<parcelCount; i++){
		let place = randomPick(Object.keys(roadGraph));
		let address;
		do {
			address = randomPick(Object.keys(roadGraph));
		} while (place == address);

		parcels.push({place, address});
	}

	return new VillageState('Post Office', parcels);
}

// Test the random robot
runRobot(VillageState.random(), randomRobot);
console.log('Random robot finishes\n\n');



/*
	Manual route.

	We can figure out a route that covers all destinations in the
	graph, if the robot can go through the route twice, then all 
	parcels would be picked up and delivered.
*/

// the route is a list of next stops, starting from Post Office.
const mailRoute = [
	"Alice's House", "Cabin", "Alice's House", "Bob's House",
    "Town Hall", "Daria's House", "Ernie's House",
    "Grete's House", "Shop", "Grete's House", "Farm",
    "Marketplace", "Post Office"
];

// a robot that starts from Post Office, going through all destinations.
// memory is list of remaining next stops to go.
function routeRobot(state, memory){
	if (memory.length == 0){
		memory = mailRoute;	// if all stops reached, start all over again.
	}

	return [memory[0], memory.slice(1)];
}

runRobot(VillageState.random(), routeRobot, []);
console.log('Route robot finishes\n\n');



/*
	Find route automatically.

	Here is a robot that finds its way from point A to B by itself.
*/

// input: graph, from (point A), to (point B)
// output: an array containing the list of next stops from A to B.
//
// A recursive version
//
function findRoute2(graph, from, to){
	if (from == to) return [];

	for (let nextStop of graph[from]){
		let result = findPath(nextStop, to, [from, nextStop]);
		if (result) return result.slice(1);
	}

	function findPath(from, to, history){
		// console.log(history);
		if (from == to) return history;
		for (let nextStop of graph[from]){
			if (history.includes(nextStop)) continue;
			let result = findPath(nextStop, to, history.concat(nextStop));
			if (result) return result;
		}
		return null;
	}
}

// test it.
let testGraph = {
	'A':['B', 'F'],
	'B':['A', 'D', 'C'],
	'C':['B', 'E', 'F'],
	'D':['B'],
	'E':['C'],
	'F':['A', 'G'],
	'G':['F']
};

console.log(findRoute2(testGraph, 'C', 'A'));
console.log(findRoute2(testGraph, 'A', 'E'));
console.log(findRoute2(testGraph, 'A', 'G'));	// B-C-F-G
console.log('End of findRoute2\n\n');


/*
	The non-recursive version from the book, looks more elegant.

	The search result is also different. This one finds a shorter path than
	the recursive one.

	Because in the resursive mode, the algorithm tries all all possibilities
	in one branch first, if not work, then it switches to next branch.
	When searching for path from A to G, it tries node B first, B eventually
	reaches G, therefore the route is B-C-F-G. The shorter branch F-G is not
	tried at all.

	In the non-resursive version, we search all possible paths in parallel, in
	the case of searching for paths from A to G, it works like

	Round	Possible path added
	1		B, F
	2		B-D, B-C
	3		F-G // found! (note path F-C is not searched becuase node C is
				// already in path B-C)


*/
function findRoute(graph, from, to){
	let work = [{at: from, route: []}];
	for (let i=0; i<work.length; i++){
		let {at, route} = work[i];
		for (let place of graph[at]){
			if (place == to) return route.concat(place);
			if (!work.some(w => w.at == place)){	// cannot revisit those
													// places already visited
				work.push({at: place, route: route.concat(place)});
				// console.log(`i = ${i}, ${work}`);
			}
		}
	}
}

console.log(findRoute(testGraph, 'C', 'A'));
console.log(findRoute(testGraph, 'A', 'E'));
console.log(findRoute(testGraph, 'A', 'G'));	// F-G

</script>
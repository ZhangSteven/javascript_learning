<script>
/*
	Project: A Robot
*/

let x = Object.create(null);	// an object with no properties
								// no prototype
console.log(x);

let y = {}						// an object with prototype Object.prototype
								// has methods like hasOwnProperty() etc.
console.log(y);

// roads in the town.
const roads = [
	"Alice's House-Bob's House",   "Alice's House-Cabin",
	"Alice's House-Post Office",   "Bob's House-Town Hall",
	"Daria's House-Ernie's House", "Daria's House-Town Hall",
	"Ernie's House-Grete's House", "Grete's House-Farm",
	"Grete's House-Shop",          "Marketplace-Farm",
	"Marketplace-Post Office",     "Marketplace-Shop",
	"Marketplace-Town Hall",       "Shop-Town Hall"
];

// But the array of strings isn't very interesting to work with. What we
// are interested in is the destination that we can reach from a given
// place. So here, we convert the roads into a data structure that, for
// each place, tells us what can be reached from there.
function buildGraph(edges){
	let graph = Object.create(null);
	function addEdge(from, to){
		if (graph[from] == undefined){
			graph[from] = [to];
		} else {
			graph[from].push(to);
		}
	}

	for (let [from, to] of roads.map(r => r.split('-'))){
		addEdge(from, to);
		addEdge(to, from);
	}

	return graph;
}

const roadGraph = buildGraph(roads);
console.log(roadGraph);

/*
	If we define a class for each type of things in the problem, like
	the robot, the houses, the roads, the parcels, then we may end up
	a program with lots of interconnected objects each having their
	own state, which is hard to understand and easy to break.

	Instead, let's condense the village's state down to the minimul set
	of values that define it. There's the robot's current location and
	the collection of undelivered parcels, each of which has a current
	location and a destination address.
*/
class VillageState {
	constructor(place, parcels) {
		this.place = place;
		this.parcels = parcels;
	}

	/*
		Update the state of all parcels {place, address}, as below:

		1. For those not at the current location (p.place != this.place), 
			they are not picked up yet, so no change.
		2. For those at the current location, they are picked up and
			moved to next stop (p.place = destination).
		3. Remove those delivered (p.place = p.address).

		Finally return a new VillageState object reflecting the new
		state, the robot's location and the parcels' state.
	*/
	move(destination){
		if (!roadGraph[this.place].includes(destination)) return this;
		let parcels = this.parcels.map(p => {
			if (p.place != this.place) {
				return p;
			} else {
				return {place: destination, address: p.address};
			}
		}).filter(p => p.place != p.address);

		return new VillageState(destination, parcels);
	}
}

// test it.
let first = new VillageState('Post Office', 
							[{place: 'Post Office', address: "Alice's House"}]);
let next = first.move("Alice's House");
console.log(next.place);
console.log(next.parcels);
console.log(first.place);



/*
	Make a delivery robot.

	Since we already have the VillageState object to describe the state
	of the world, what we need is a robot that can tell what is the next
	move. The robot can be seen as a function whose input is the current
	state (state), maybe past moves (memory), and return the decision 
	(direction) and updated memory.
*/
function runRobot(state, robot, memory){
	for (let turn=0;;turn++){
		if (state.parcels.length == 0){
			console.log(`Done in ${turn} turns`);
			break;
		}

		let direction;
		[direction, memory] = robot(state, memory);
		state = state.move(direction);
		console.log(`Moved to ${direction}`);
	}
}



/*
	A random robot.

	The simpliest robot just moves randomly in every turn. Given enough
	time, we can expect it to run into every location that has parcels
	to deliver and send those parcels to their destination.
*/
function randomPick(array){
	let choice = Math.floor(Math.random() * array.length);
	return array[choice];
}

function randomRobot(state){
	return [randomPick(roadGraph[state.place]), null];
}



/*
	Test robots.

	To setup the test, we can add a static method to the VillageState
	class, random, to initialize the setup of parcels waiting to be
	delivered. The starting position the robot is assumed to be at
	'Post Office'.
*/
VillageState.random = function(parcelCount = 5){
	let parcels = [];
	for (let i=0; i<parcelCount; i++){
		let place = randomPick(Object.keys(roadGraph));
		let address;
		do {
			address = randomPick(Object.keys(roadGraph));
		} while (place == address);

		parcels.push({place, address});
	}

	return new VillageState('Post Office', parcels);
}

// Test the random robot
runRobot(VillageState.random(), randomRobot);
console.log('Random robot finishes\n\n');



/*
	Manual route.

	We can figure out a route that covers all destinations in the
	graph, if the robot can go through the route twice, then all 
	parcels would be picked up and delivered.
*/

// the route is a list of next stops, starting from Post Office.
const mailRoute = [
	"Alice's House", "Cabin", "Alice's House", "Bob's House",
    "Town Hall", "Daria's House", "Ernie's House",
    "Grete's House", "Shop", "Grete's House", "Farm",
    "Marketplace", "Post Office"
];

// a robot that starts from Post Office, going through all destinations.
// memory is list of remaining next stops to go.
function routeRobot(state, memory){
	if (memory.length == 0){
		memory = mailRoute;	// if all stops reached, start all over again.
	}

	return [memory[0], memory.slice(1)];
}

runRobot(VillageState.random(), routeRobot, []);
console.log('Route robot finishes\n\n');



/*
	Find route automatically.

	Given a starting point and destination, find out a path that
	connects them.
*/

</script>
<script>
/*
	Project: A Robot
*/

let x = Object.create(null);	// an object with no properties
								// no prototype
console.log(x);

let y = {}						// an object with prototype Object.prototype
								// has methods like hasOwnProperty() etc.
console.log(y);

// roads in the town.
const roads = [
	"Alice's House-Bob's House",   "Alice's House-Cabin",
	"Alice's House-Post Office",   "Bob's House-Town Hall",
	"Daria's House-Ernie's House", "Daria's House-Town Hall",
	"Ernie's House-Grete's House", "Grete's House-Farm",
	"Grete's House-Shop",          "Marketplace-Farm",
	"Marketplace-Post Office",     "Marketplace-Shop",
	"Marketplace-Town Hall",       "Shop-Town Hall"
];

// But the array of strings isn't very interesting to work with. What we
// are interested in is the destination that we can reach from a given
// place. So here, we convert the roads into a data structure that, for
// each place, tells us what can be reached from there.
function buildGraph(edges){
	let graph = Object.create(null);
	function addEdge(from, to){
		if (graph[from] == undefined){
			graph[from] = [to];
		} else {
			graph[from].push(to);
		}
	}

	for (let [from, to] of roads.map(r => r.split('-'))){
		addEdge(from, to);
		addEdge(to, from);
	}

	return graph;
}

const roadGraph = buildGraph(roads);
console.log(roadGraph);

/*
	If we define a class for each type of things in the problem, like
	the robot, the houses, the roads, the parcels, then we may end up
	a program with lots of interconnected objects each having their
	own state, which is hard to understand and easy to break.

	Instead, let's condense the village's state down to the minimul set
	of values that define it. There's the robot's current location and
	the collection of undelivered parcels, each of which has a current
	location and a destination address.
*/
class VillageState {
	constructor(place, parcels) {
		this.place = place;
		this.parcels = parcels;
	}

	// provide a destination for the next move. If the destion is out of
	// reach from current location, then no change.
	// If it is reachable, then check is there any parcels whose destionation
	// address match the destination address, if yes, then remove it from
	// the list of parcels.
	move(destination){
		if (!roadGraph[this.place].includes(destination)) return this;

	}
}

</script>
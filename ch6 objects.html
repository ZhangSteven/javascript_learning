<script>

/*
	Chapter 6. The Secret Life of Objects
*/

/*
	Create an object and assign a property whose value is a function. 
*/
let rabbit = {};	// an empty object.
rabbit.speak = function(line){	// assign a function as its property.
	console.log(`The rabbit says ${line}`);
};
rabbit.speak('你好!');



let yy = '88';
let r2 = {yy};	// same as {'yy': yy} or {yy: yy}
// let r2 = {yy: yy};
console.log(r2);



/*
	When a function is called as a method - looked up as a property
	and immediately called, as in object.method() - the binding called
	"this" in its body automatically points at the object that it was
	called on.
*/
function speak(line){
	console.log(`The ${this.type} rabbit says "${line}".`);
}
let whiteRabbit = {type: 'white', speak: speak};
let hungryRabbit = {type: 'hungry', speak};
whiteRabbit.speak('HaHa');
hungryRabbit.speak('I want to eat');


// You can think of "this" as an extra argument that is passed in a 
// different way. You can pass it explicitly as below.
speak.call(hungryRabbit, 'I want to eat');



/*
	When passing a function as an argument, who needs to access to
	"this" in the wrapping scope, use arrow functions.
*/
function normalize(){
	console.log(this.coords.map(n => n/this.length));
}
normalize.call({coords: [1,3,10], length: 5});

/*
	The below doesn't work. When we use function(n) {return n/this.length;}
	to replace n => n/this.length, the function fails to access "this"
	in the wrapping scope.

function normalize2(){
	console.log(this.coords.map(function(n){return n/this.length;}));
}
normalize2.call({coords: [1,3,10], length: 5});
*/



/*
	Prototypes.

	A prototype is another object that is used as a fallback source
	of properties. When an object gets a request for a property that 
	it does not have, its prototype will be searched for the property,
	then prototype's prototype, and so on.

	The prototype relations of Javascript objects form a tree-shaped
	structure, and at the root of this structure sits Object.prototype.
*/
console.log(Object.getPrototypeOf({}) == Object.prototype);
console.log(Object.getPrototypeOf({}));	// Object
console.log(Object.getPrototypeOf(Object));
console.log(Object.getPrototypeOf(Math.max) == Function.prototype);
console.log(Object.getPrototypeOf([]) == Array.prototype);
console.log(Object.getPrototypeOf('') == String.prototype);



/*
	Create an object with Object.create().
*/
let protoRabbit = {	// an object with a method called speak()
	/*
	speak: function(line){
		console.log(`The ${this.type} rabbit says "${line}"`);
	}
	*/

	// same as above, just a short notation.
	speak(line){
		console.log(`The ${this.type} rabbit says "${line}"`);
	}

};

// create a new object just like object "protoRabbit" (the prototype)
let killerRabbit = Object.create(protoRabbit);
killerRabbit.type = 'killer';
killerRabbit.speak('SKREEEE!');

// In the above, we need to create and initialize the new object in
// 2 steps. We can use a function to wrap it.
function makeRabbit(type){
	let rabbit = Object.create(protoRabbit);
	rabbit.type = type;
	return rabbit;
}
makeRabbit('killer').speak('haha');



/*
	Create an object with keyword "new" and a constructor function.
*/

// The constructor function (needs to be called with keyword "new")
function Rabbit(type){
	this.type = type;
}

/*
	A constructor fucntion like Rabbit (all functions, in fact), 
	automatically gets a property named "prototype", which by default
	holds a plain, empty object that derives from Object.prototype.

	When we do:

	let weirdRabbit = new Rabbit('weird');

	It is the same as:

	let weirdRabbit = Object.create(Rabbit.prototype);
	weirdRabbit.type = 'weird';
*/
console.log(Rabbit.prototype);	// strange? it already gets the speak 
								// property
Rabbit.prototype.speak = function(line){
	console.log(`The ${this.type} rabbit says "${line}"`);
};
let weirdRabbit = new Rabbit('weird');
weirdRabbit.speak('Hello');
console.log(weirdRabbit);


// you can do the following as well.
Rabbit.prototype = {
	move(distance){
		console.log(`The ${this.type} rabbit moves ${distance} meters`);
	},

	eat(food){
		console.log(`The ${this.type} rabbit eats ${food}`);
	}
};
let blackRabbit = new Rabbit('black');
blackRabbit.move(5);
blackRabbit.eat('carrot');
console.log(Rabbit.prototype);



/*
	The class notation.

	In order to wrap the constructor function and the methods definition
	together, we can use the class notation. But under the cover, it does
	exactly the same things:

	1. Bind methods as properties of the Rabbit.prototype object.
	2. Create a new object with Object.create(), model after Rabbit.prototype.
	3. Initialize the new object's properties.

	For the moment, class declarations only allows methods - properties that
	hold functions - to be added to the prototype.
*/
class GoodRabbit {

	// this defines constructor function GoodRabbit()
	constructor(type){
		this.type = type;
	}

	speak(line){
		console.log(`The ${this.type} rabbit says "${line}"`);
	}
}

let okRabbit = new GoodRabbit('ok');
okRabbit.speak('Oooops');
console.log(GoodRabbit.prototype);	// same as Rabbit.prototype above.
									// However, the "small" property got
									// shown here.


/*
	Overriding derived properties.
*/

GoodRabbit.prototype.teeth = 'small';
let badRabbit = new GoodRabbit('bad');
console.log(badRabbit.teeth);			// badRabbit doesn't have "teeth"
										// property, fall back on its prototype
										// GoodRabbit.prototype

okRabbit.teeth = 'big, sharp, bloody';	// add a new property "teeth" to
										// okRabbit.
console.log(okRabbit.teeth);
console.log(badRabbit.teeth);			// not affected.

</script>